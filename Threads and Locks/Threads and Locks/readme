2) Creating threads

The issue was that there were duplicate ID's. More specifically, when creating the pThreads in the for loop, the address of i is being passed. Furthermore, the cast of id inside the "mythread" function was incorrect. To solve this, pass a void pointer to i by adding "(void*)" and remove "&". Next, one should initialize "id" in the function "mythread" to "size_t" and convert "arg" to "size_t" as well. 

3) Using Locks

Experiment 1: After running the program multiple times, it does not generate the same result as the sequential version. Furthermore, the program does not generate the same result after each run. The sum value is inconsistent. This problem is similar to the "critical section" issue discussed in the "Process Synchronization" lecture. Concurrent access to shared data, in this case the variable "sum", results in data inconsistency. There is more than one thread accessing the critical section and adding to sum, thus resulting in data inconsistency. 

Expiriment 2: After running the program multiple times, it does generate the same result as the sequential version. Furthermore, the program does generate the same result after each run. The sum value is consistent and always outputing the value "49496438". The reason it isn't inconsistent like the first expiriment was the use of mutex. Mutex gives us the ability to lock and unlock. Instead of having more than one thread accessing the critical section, we can lock the mutex to have only one thread accessing the critical section. Then unlocking the mutex after updating the shared data. This removes concurrent access to shared data and lets one thread at a time change the shared data. It gives a protection around shared datas and prevents data inconsistency. However, this method of using the mutex inside the for loop is very inefficient because the program needs to lock and unlock many times. This can be fixed at expiriment 3. 

Expiriment 3: The previous expiriment needed to lock and unlock the mutex multiple times which is slow and inefficient. A better solution is having two sum variables. The variable "sum" is the sum of all the calculations. The second variable, "localSum", is only accessible in the function "sum_array". The "localSum" variable gives it protection from other pThreads from accessing it. That way, only one pThread can access "localSum". Once the calculations are done, that is the for loop has completed summing up the array, we need to add it to the variable "sum" which is the sum of everything. Since "sum" is a global variable, we still need to protect it by using locks. We lock the mutex, add the sum of "localSum" to "sum", then unlock the mutex. This method is efficient as it only needs to lock and unlock once for each thread while still having proper synchronization. Meaning that it would need to lock and unlock 10x for all the pThreads. The program generated the same result as expiriment 2 and sequential.c. Both Expiriment 2 and 3 should generate the same result as sequential.c asnthey are both multi-threaded versions.
 
   
